<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Car Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }

    #controls {
      position: absolute;
      bottom: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      z-index: 10;
    }

    #steering {
      width: 240px;
      height: 240px;
      border-radius: 50%;
      touch-action: none;
      background: conic-gradient(gold 0deg 180deg, green 180deg 360deg);
      border: 8px solid transparent;
      box-sizing: border-box;
      transition: transform 0.05s linear;
    }

    .pedals {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    button {
      width: 120px;
      height: 80px;
      font-size: 18px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      color: white;
    }

    #accelerate { background: green; }
    #brake { background: red; }

    #gameOverScreen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    #gameOverCard {
      background: white;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 0 40px gold;
      text-align: center;
      font-family: 'Arial', sans-serif;
      color: black;
    }

    #gameOverCard h1 {
      font-size: 36px;
      color: red;
    }

    #gameOverCard button {
      padding: 15px 30px;
      background: linear-gradient(to right, gold, green);
      border: none;
      font-size: 20px;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="pedals">
      <button id="brake">Brake</button>
      <button id="accelerate">Accelerate</button>
    </div>
    <div id="steering"></div>
  </div>

  <div id="gameOverScreen">
    <div id="gameOverCard">
      <h1>ðŸ’¥ Game Over!</h1>
      <p>You hit a building</p>
      <button onclick="restartGame()">Restart</button>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // Sky blue

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(100, 200, 100);
scene.add(sun);
scene.add(new THREE.AmbientLight(0x404040, 2));

// Car
const car = new THREE.Mesh(
  new THREE.BoxGeometry(6, 2, 10),
  new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
car.position.set(0, 1, 0);
scene.add(car);

// Movement
let speed = 0, angle = 0, steerAngle = 0, isGameOver = false;
const maxSpeed = 6;

// Junction & Road System
const tileSize = 500;
const tiles = new Map();

function key(x, z) {
  return `${x},${z}`;
}

function createTile(x, z) {
  if (tiles.has(key(x, z))) return;

  // Z-Road
  const zRoad = new THREE.Mesh(
    new THREE.BoxGeometry(100, 1, tileSize),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  zRoad.position.set(x, -0.5, z);
  scene.add(zRoad);

  // X-Road
  const xRoad = new THREE.Mesh(
    new THREE.BoxGeometry(tileSize, 1, 100),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  xRoad.position.set(x, -0.5, z);
  scene.add(xRoad);

  // Buildings
  const colors = [0x66aaff, 0x66ff66, 0xaa7744, 0xaa66cc];
  for (let i = 0; i < 4; i++) {
    const bx = x + (i < 2 ? -80 : 80) + (Math.random() * 40 - 20);
    const bz = z + (i % 2 === 0 ? -80 : 80) + (Math.random() * 40 - 20);
    const h = 200 + Math.random() * 200;
    const building = new THREE.Mesh(
      new THREE.BoxGeometry(20, h, 20),
      new THREE.MeshStandardMaterial({ color: colors[i % colors.length] })
    );
    building.position.set(bx, h / 2, bz);
    scene.add(building);
  }

  tiles.set(key(x, z), true);
}

function updateTiles() {
  const cx = Math.round(car.position.x / tileSize) * tileSize;
  const cz = Math.round(car.position.z / tileSize) * tileSize;

  // 3x3 area around car
  for (let dx of [-1, 0, 1]) {
    for (let dz of [-1, 0, 1]) {
      createTile(cx + dx * tileSize, cz + dz * tileSize);
    }
  }
}

// Collision Detection (placeholder â€” for buildings later)
function checkCollision() {
  return false; // update if buildings become more interactive
}

function gameOver() {
  isGameOver = true;
  speed = 0;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function restartGame() {
  window.location.reload();
}

function animate() {
  requestAnimationFrame(animate);

  updateTiles();
  if (!isGameOver && checkCollision()) gameOver();

  angle += steerAngle * (speed / 5);
  if (Math.abs(steerAngle) < 0.002 && Math.abs(angle) > 0.001) {
    angle *= 0.95;
  }

  car.rotation.y = angle;
  car.position.x -= Math.sin(angle) * speed;
  car.position.z -= Math.cos(angle) * speed;

  // ðŸš€ Smart camera follows car direction
  const cameraDistance = 60;
  const cameraHeight = 30;
  const camX = car.position.x + Math.sin(angle) * cameraDistance;
  const camZ = car.position.z + Math.cos(angle) * cameraDistance;
  const camY = car.position.y + cameraHeight;

  camera.position.set(camX, camY, camZ);
  camera.lookAt(car.position);

  renderer.render(scene, camera);
}
animate();

// Controls (same)
let accelerating = false, braking = false;
setInterval(() => {
  if (accelerating) speed = Math.min(speed + 0.1, maxSpeed);
  else if (braking) speed = Math.max(speed - 0.2, 0);
  else {
    speed *= 0.98;
    if (speed < 0.05) speed = 0;
  }
}, 50);

document.getElementById('accelerate').addEventListener('touchstart', () => accelerating = true);
document.getElementById('accelerate').addEventListener('touchend', () => accelerating = false);
document.getElementById('accelerate').addEventListener('mousedown', () => accelerating = true);
document.getElementById('accelerate').addEventListener('mouseup', () => accelerating = false);

document.getElementById('brake').addEventListener('touchstart', () => braking = true);
document.getElementById('brake').addEventListener('touchend', () => braking = false);
document.getElementById('brake').addEventListener('mousedown', () => braking = true);
document.getElementById('brake').addEventListener('mouseup', () => braking = false);

// Steering
const steering = document.getElementById('steering');
let dragging = false, currentRotation = 0, lastAngle = 0;

function getAngle(e, cx, cy) {
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return Math.atan2(clientY - cy, clientX - cx);
}

function handleSteeringStart(e) {
  dragging = true;
  const rect = steering.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  lastAngle = getAngle(e, cx, cy);
}

function handleSteeringMove(e) {
  if (!dragging) return;
  const rect = steering.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const angleNow = getAngle(e, cx, cy);
  let delta = angleNow - lastAngle;
  if (delta > Math.PI) delta -= 2 * Math.PI;
  if (delta < -Math.PI) delta += 2 * Math.PI;
  currentRotation += delta * 180 / Math.PI;
  currentRotation = Math.max(-180, Math.min(180, currentRotation));
  steering.style.transform = `rotate(${currentRotation}deg)`;
  lastAngle = angleNow;
  steerAngle = -currentRotation * 0.0015;
}

function handleSteeringEnd() {
  dragging = false;
}
steering.addEventListener('touchstart', handleSteeringStart);
steering.addEventListener('touchmove', handleSteeringMove);
steering.addEventListener('touchend', handleSteeringEnd);
steering.addEventListener('mousedown', handleSteeringStart);
window.addEventListener('mousemove', handleSteeringMove);
window.addEventListener('mouseup', handleSteeringEnd);

setInterval(() => {
  if (!dragging && currentRotation !== 0) {
    currentRotation *= 0.9;
    if (Math.abs(currentRotation) < 0.5) currentRotation = 0;
    steering.style.transform = `rotate(${currentRotation}deg)`;
    steerAngle = -currentRotation * 0.0015;
  }
}, 16);
</script>
</body>
</html>
